package repositories

import (
    "database/sql"

    "github.com/hospedate/backyard/log"
    "github.com/hospedate/backyard/models"
    sqlTmp "github.com/hospedate/backyard/sql"
)

type InvitationsRepository interface {
    GetById(id *models.InvitationId) *models.Invitation
    Save(request *models.NewInvitationRequest) (*models.Invitation, error)
    Edit(invitationEditRequest models.InvitationEditRequest) (*models.Invitation, error)
    Search(queryParams *models.InvitationsSearchParams) []*models.Invitation
}

type pgInvitationsRepository struct {
    db     *sql.DB
    logger log.Logger
}

func NewInvitationsRepository(db *sql.DB) InvitationsRepository {
    logger := log.NewLogger("InvitationsRepository", string(log.INFO_LEVEL))
    return &pgInvitationsRepository{
        db:     db,
        logger: logger,
    }
}

func (r *pgInvitationsRepository) GetById(id *models.InvitationId) *models.Invitation {
    result := r.db.QueryRow(sqlTmp.Invitations_fetch_by_id, id.String())
    invitation, err := InvitationFromResult(result)
    if err != nil {
        return nil
    }
    return invitation
}

func (r *pgInvitationsRepository) Save(request *models.NewInvitationRequest) (*models.Invitation, error) {
    invitationId := models.NewRandomInvitationId()

    _, err := r.db.Exec(
        sqlTmp.Invitations_new_invitation,
        invitationId.String(),
        request.Kind,
        request.GeneratedBy,
    )

    if err != nil {
        r.logger.Info("Unknown error creating new user invitation: ", err.Error())
        return nil, UnknownError
    }

    r.logger.Infof("New user invitation %v created generated by user %v", invitationId.String(), request.GeneratedBy)

    return r.GetById(invitationId), nil
}

func (r *pgInvitationsRepository) Edit(invitationEditRequest models.InvitationEditRequest) (*models.Invitation, error) {
    // Build the base query template
    query, queryArgs := buildEditQuery(
        sqlTmp.Invitations_edit_base_query,
        GetParamFieldsPresent(invitationEditRequest),
        "WHERE id = ?",
        []any{invitationEditRequest.Id.String()},
    )
    stmt, err := r.db.Prepare(query)

    if err != nil {
        r.logger.Error("Error when creating query template", err.Error())
        return nil, err
    }
    _, err = stmt.Exec(queryArgs...)
    if err != nil {
        r.logger.Error("Error when trying to update invitation: ", err.Error())
        return nil, err
    } else {
        return r.GetById(&invitationEditRequest.Id), nil
    }
}

func (r *pgInvitationsRepository) Search(queryParams *models.InvitationsSearchParams) []*models.Invitation {
    // Build the base query template
    queryTmp := sqlTmp.Invitations_search_base_query
    queryArgs := []any{}

    // Add filters if necessary
    if queryParams.HasGeneratedBy() {
        queryTmp += " AND generated_by = ? "
        queryArgs = append(queryArgs, queryParams.GetGeneratedBy())
    }

    if queryParams.HasUsedBy() {
        queryTmp += " AND used_by = ? "
        queryArgs = append(queryArgs, queryParams.GetUsedBy())
    }

    // change template symbols from ? to $1, etc
    queryTmp = ReplaceArgsTemplate(queryTmp)

    // Exec the query and get the results
    stmt, err := r.db.Prepare(queryTmp)

    if err != nil {
        r.logger.Error("Error when creating query template", err.Error())
        return nil
    }

    rows, err := stmt.Query(queryArgs...)
    if err == sql.ErrNoRows {
        return []*models.Invitation{}
    } else if err != nil {
        r.logger.Error("Error when searching invitations: ", err.Error())
        return nil
    }

    defer rows.Close()

    return r.fillInvitationSlice(rows)
}

func (r *pgInvitationsRepository) fillInvitationSlice(rows *sql.Rows) []*models.Invitation {
    invitations := []*models.Invitation{}

    for rows.Next() {
        invitation, err := InvitationFromResult(rows)

        if err != nil {
            r.logger.Error("Invitation Scan failed: ", err.Error())
            return nil
        }
        invitations = append(invitations, invitation)
    }
    return invitations
}

func InvitationFromResult(result RowScanner) (*models.Invitation, error) {
    invitation := models.Invitation{}
    var invitationIdStr string
    var invitationKindStr string
    err := result.Scan(&invitationIdStr, &invitation.UsedBy, &invitationKindStr, &invitation.GeneratedBy, &invitation.CreatedAt)
    if err != nil {
        return nil, err
    }

    // create invitationId
    invitationId, err := models.NewInvitationIdFromStr(invitationIdStr)
    if err != nil {
        return nil, err
    }
    invitation.Id = *invitationId
    // create invitationKind
    invitationKind, err := models.NewInvitationKind(invitationKindStr)
    if err != nil {
        return nil, err
    }
    invitation.Kind = *invitationKind

    return &invitation, nil
}
